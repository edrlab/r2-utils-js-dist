{"version":3,"file":"zipInjector.js","sourceRoot":"","sources":["../../../../../src/_utils/zip/zipInjector.ts"],"names":[],"mappings":"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","sourcesContent":["// ==LICENSE-BEGIN==\n// Copyright 2017 European Digital Reading Lab. All rights reserved.\n// Licensed to the Readium Foundation under one or more contributor license agreements.\n// Use of this source code is governed by a BSD-style license\n// that can be found in the LICENSE file exposed on Github (readium) in the project repository.\n// ==LICENSE-END==\n\nimport * as debug_ from \"debug\";\nimport * as fs from \"fs\";\nimport * as yauzl from \"yauzl\";\nimport * as yazl from \"yazl\";\n\nconst debug = debug_(\"r2:utils#zip/zipInjector\");\n\nenum InjectType {\n    FILE,\n    BUFFER,\n    STREAM,\n}\n\nexport function injectStreamInZip(\n    destPathTMP: string,\n    destPathFINAL: string,\n    stream: NodeJS.ReadableStream,\n    zipEntryPath: string,\n    zipError: (e: any) => void,\n    doneCallback: () => void) {\n\n    injectObjectInZip(destPathTMP, destPathFINAL,\n        stream, InjectType.STREAM,\n        zipEntryPath, zipError, doneCallback);\n}\n\nexport function injectBufferInZip(\n    destPathTMP: string,\n    destPathFINAL: string,\n    buffer: Buffer,\n    zipEntryPath: string,\n    zipError: (e: any) => void,\n    doneCallback: () => void) {\n\n    injectObjectInZip(destPathTMP, destPathFINAL,\n        buffer, InjectType.BUFFER,\n        zipEntryPath, zipError, doneCallback);\n}\n\nexport function injectFileInZip(\n    destPathTMP: string,\n    destPathFINAL: string,\n    filePath: string,\n    zipEntryPath: string,\n    zipError: (e: any) => void,\n    doneCallback: () => void) {\n\n    injectObjectInZip(destPathTMP, destPathFINAL,\n        filePath, InjectType.FILE,\n        zipEntryPath, zipError, doneCallback);\n}\n\nfunction injectObjectInZip(\n    destPathTMP: string,\n    destPathFINAL: string,\n    contentsToInject: any,\n    typeOfContentsToInject: InjectType,\n    zipEntryPath: string,\n    zipError: (e: any) => void,\n    doneCallback: () => void) {\n\n    yauzl.open(destPathTMP, { lazyEntries: true, autoClose: false }, (err: any, zip: any) => {\n        if (err) {\n            debug(\"yauzl init ERROR\");\n            zipError(err);\n            return;\n        }\n\n        const zipfile = new yazl.ZipFile();\n\n        zip.on(\"error\", (erro: any) => {\n            debug(\"yauzl ERROR\");\n            zipError(erro);\n        });\n\n        zip.readEntry(); // next (lazyEntries)\n        zip.on(\"entry\", (entry: any) => {\n            // if (/\\/$/.test(entry.fileName)) {\n            if (entry.fileName[entry.fileName.length - 1] === \"/\") {\n                // skip directories / folders\n            } else if (entry.fileName === zipEntryPath) {\n                // skip injected entry\n            } else {\n                // debug(entry.fileName);\n                // debug(entry);\n                zip.openReadStream(entry, (errz: any, stream: NodeJS.ReadableStream) => {\n                    if (err) {\n                        debug(\"yauzl openReadStream ERROR\");\n                        debug(errz);\n                        zipError(errz);\n                        return;\n                    }\n                    // entry.uncompressedSize\n                    const compress = entry.fileName !== \"mimetype\";\n                    zipfile.addReadStream(stream, entry.fileName, { compress });\n                });\n            }\n            zip.readEntry(); // next (lazyEntries)\n        });\n\n        zip.on(\"end\", () => {\n            debug(\"yauzl END\");\n\n            if (typeOfContentsToInject === InjectType.FILE) {\n                zipfile.addFile(contentsToInject as string, zipEntryPath);\n\n            } else if (typeOfContentsToInject === InjectType.BUFFER) {\n                zipfile.addBuffer(contentsToInject as Buffer, zipEntryPath);\n\n            } else if (typeOfContentsToInject === InjectType.STREAM) {\n                zipfile.addReadStream(contentsToInject as NodeJS.ReadableStream, zipEntryPath);\n\n            } else {\n                debug(\"yazl FAIL to inject! (unknown type)\");\n            }\n\n            zipfile.end();\n\n            const destStream2 = fs.createWriteStream(destPathFINAL);\n            zipfile.outputStream.pipe(destStream2);\n            // response.on(\"end\", () => {\n            // });\n            destStream2.on(\"finish\", () => {\n                doneCallback();\n            });\n            destStream2.on(\"error\", (ere: any) => {\n                zipError(ere);\n            });\n        });\n\n        zip.on(\"close\", () => {\n            debug(\"yauzl CLOSE\");\n        });\n    });\n}\n"]}