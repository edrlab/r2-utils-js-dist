{"version":3,"file":"RangeStream.js","sourceRoot":"","sources":["../../../../../src/_utils/stream/RangeStream.ts"],"names":[],"mappings":";;;AAOA,gCAAgC;AAChC,mCAAmC;AAEnC,MAAM,KAAK,GAAG,MAAM,CAAC,6BAA6B,CAAC,CAAC;AAEpD,MAAa,WAAY,SAAQ,kBAAS;IAKtC,YAAqB,WAAmB,EAAW,SAAiB,EAAW,YAAoB;QAC/F,KAAK,EAAE,CAAC;QADS,gBAAW,GAAX,WAAW,CAAQ;QAAW,cAAS,GAAT,SAAS,CAAQ;QAAW,iBAAY,GAAZ,YAAY,CAAQ;QAE/F,IAAI,CAAC,aAAa,GAAG,CAAC,CAAC;QACvB,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;QACtB,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;QACpB,IAAI,CAAC,EAAE,CAAC,KAAK,EAAE,GAAG,EAAE;QAEpB,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,EAAE,CAAC,QAAQ,EAAE,GAAG,EAAE;QAEvB,CAAC,CAAC,CAAC;IACP,CAAC;IAEM,MAAM,CAAC,QAAoB;QAE9B,QAAQ,EAAE,CAAC;IACf,CAAC;IAEM,UAAU,CAAC,KAAa,EAAE,SAAiB,EAAE,QAAoB;QACpE,IAAI,CAAC,aAAa,IAAI,KAAK,CAAC,MAAM,CAAC;QAGnC,IAAI,IAAI,CAAC,QAAQ,EAAE;YACf,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;gBACd,KAAK,CAAC,iBAAiB,CAAC,CAAC;gBACzB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;gBACnB,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aACnB;iBAAM;gBACH,KAAK,CAAC,wCAAwC,CAAC,CAAC;gBAChD,IAAI,CAAC,GAAG,EAAE,CAAC;aACd;SACJ;aAAM;YACH,IAAI,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,WAAW,EAAE;gBAEvC,IAAI,UAAU,GAAG,CAAC,CAAC;gBACnB,IAAI,QAAQ,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;gBAEhC,UAAU,GAAG,IAAI,CAAC,WAAW,GAAG,CAAC,IAAI,CAAC,aAAa,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC;gBACpE,IAAI,UAAU,GAAG,CAAC,EAAE;oBAChB,UAAU,GAAG,CAAC,CAAC;iBAClB;gBAED,IAAI,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,SAAS,EAAE;oBACrC,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;oBACrB,QAAQ,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC;iBACnE;gBAED,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,UAAU,EAAE,QAAQ,GAAG,CAAC,CAAC,CAAC,CAAC;gBAEjD,IAAI,IAAI,CAAC,QAAQ,EAAE;oBAEf,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;oBACnB,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;oBAChB,IAAI,CAAC,GAAG,EAAE,CAAC;iBACd;aACJ;iBAAM;aAGN;SACJ;QAED,QAAQ,EAAE,CAAC;IACf,CAAC;CACJ;AApED,kCAoEC","sourcesContent":["// ==LICENSE-BEGIN==\n// Copyright 2017 European Digital Reading Lab. All rights reserved.\n// Licensed to the Readium Foundation under one or more contributor license agreements.\n// Use of this source code is governed by a BSD-style license\n// that can be found in the LICENSE file exposed on Github (readium) in the project repository.\n// ==LICENSE-END==\n\nimport * as debug_ from \"debug\";\nimport { Transform } from \"stream\";\n\nconst debug = debug_(\"r2:utils#stream/RangeStream\");\n\nexport class RangeStream extends Transform {\n    private bytesReceived: number;\n    private finished: boolean;\n    private closed: boolean;\n\n    constructor(readonly streamBegin: number, readonly streamEnd: number, readonly streamLength: number) {\n        super();\n        this.bytesReceived = 0;\n        this.finished = false;\n        this.closed = false;\n        this.on(\"end\", () => {\n            // debug(\"------ RangeStream END\");\n        });\n        this.on(\"finish\", () => {\n            // debug(\"------ RangeStream FINISH\");\n        });\n    }\n\n    public _flush(callback: () => void): void {\n        // debug(\"FLUSH\");\n        callback();\n    }\n\n    public _transform(chunk: Buffer, _encoding: string, callback: () => void): void {\n        this.bytesReceived += chunk.length;\n        // debug(`_transform bytesReceived ${this.bytesReceived}`);\n\n        if (this.finished) {\n            if (!this.closed) {\n                debug(\"???? CLOSING...\");\n                this.closed = true;\n                this.push(null);\n            } else {\n                debug(\"???? STILL PIPE CALLING _transform ??!\");\n                this.end();\n            }\n        } else {\n            if (this.bytesReceived > this.streamBegin) {\n\n                let chunkBegin = 0;\n                let chunkEnd = chunk.length - 1;\n\n                chunkBegin = this.streamBegin - (this.bytesReceived - chunk.length);\n                if (chunkBegin < 0) {\n                    chunkBegin = 0;\n                }\n\n                if (this.bytesReceived > this.streamEnd) {\n                    this.finished = true;\n                    chunkEnd = chunk.length - (this.bytesReceived - this.streamEnd);\n                }\n                // console.log(`CHUNK: ${chunkBegin}-${chunkEnd}/${chunk.length}`);\n                this.push(chunk.slice(chunkBegin, chunkEnd + 1));\n\n                if (this.finished) {\n                    // debug(\"FINISHING...\");\n                    this.closed = true;\n                    this.push(null);\n                    this.end();\n                }\n            } else {\n                // NOOP\n                // no call to this.push(), we skip the entire current chunk buffer\n            }\n        }\n\n        callback();\n    }\n}\n"]}