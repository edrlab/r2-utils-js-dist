{"version":3,"file":"xml-object.js","sourceRoot":"","sources":["../../../../../../src/_utils/xml-js-mapper/decorators/xml-object.ts"],"names":[],"mappings":";;;AAOA,kEAA6D;AAG7D,SAAgB,SAAS,CAAC,UAA2B;IACjD,OAAO,UAAC,UAAwB;QAI5B,IAAM,GAAG,GAAG,iCAAa,CAAC,UAAU,CAAC,CAAC;QAEtC,IAAI,UAAU,EAAE;YACZ,GAAG,CAAC,UAAU,GAAG,UAAU,CAAC;SAE/B;QACD,IAAI,GAAG,CAAC,UAAU,IAAI,GAAG,CAAC,UAAU,EAAE;YAClC,GAAG,CAAC,UAAU,CAAC,OAAO,CAAC,UAAC,OAAO;gBAC3B,IAAI,GAAG,CAAC,UAAU,EAAE;oBAChB,KAAK,IAAM,IAAI,IAAI,GAAG,CAAC,UAAU,EAAE;wBAC/B,IAAI,GAAG,CAAC,UAAU,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE;4BACrC,IAAI,CAAC,OAAO,CAAC,UAAU,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE;gCAClD,IAAI,CAAC,OAAO,CAAC,UAAU,EAAE;oCACrB,OAAO,CAAC,UAAU,GAAG,EAAE,CAAC;iCAC3B;gCACD,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;6BACnD;yBACJ;qBACJ;oBACD,IAAI,OAAO,CAAC,mBAAmB,EAAE;wBAC7B,OAAO,CAAC,mBAAmB,CAAC,OAAO,CAAC,UAAC,EAAE;4BACnC,IAAI,EAAE,CAAC,eAAe,IAAI,CAAC,EAAE,CAAC,YAAY,EAAE;gCACxC,EAAE,CAAC,YAAY,GAAG,OAAO,CAAC,UAAU,CAAC,CAAC;oCAClC,OAAO,CAAC,UAAU,CAAC,EAAE,CAAC,eAAe,CAAC,CAAC,CAAC;oCACxC,SAAS,CAAC;6BAEjB;wBACL,CAAC,CAAC,CAAC;qBACN;iBACJ;YACL,CAAC,CAAC,CAAC;SACN;IAML,CAAC,CAAC;AACN,CAAC;AA3CD,8BA2CC","sourcesContent":["// ==LICENSE-BEGIN==\n// Copyright 2017 European Digital Reading Lab. All rights reserved.\n// Licensed to the Readium Foundation under one or more contributor license agreements.\n// Use of this source code is governed by a BSD-style license\n// that can be found in the LICENSE file exposed on Github (readium) in the project repository.\n// ==LICENSE-END==\n\nimport { getDefinition } from \"../classes/object-definition\";\nimport { FunctionType, IXmlNamespaces } from \"../types\";\n\nexport function XmlObject(namespaces?: IXmlNamespaces) {\n    return (objectType: FunctionType): void => {\n\n        // console.log(\"########################## XmlObject NS\");\n        // console.log(objectType);\n        const def = getDefinition(objectType);\n        // console.log(def);\n        if (namespaces) {\n            def.namespaces = namespaces;\n            // console.log(namespaces);\n        }\n        if (def.namespaces && def.properties) {\n            def.properties.forEach((propDef) => {\n                if (def.namespaces) { // redundant ... TypeScript compile check :(\n                    for (const prop in def.namespaces) {\n                        if (def.namespaces.hasOwnProperty(prop)) {\n                            if (!propDef.namespaces || !propDef.namespaces[prop]) {\n                                if (!propDef.namespaces) {\n                                    propDef.namespaces = {};\n                                }\n                                propDef.namespaces[prop] = def.namespaces[prop];\n                            }\n                        }\n                    }\n                    if (propDef.xpathSelectorParsed) {\n                        propDef.xpathSelectorParsed.forEach((xp) => {\n                            if (xp.namespacePrefix && !xp.namespaceUri) {\n                                xp.namespaceUri = propDef.namespaces ?\n                                    propDef.namespaces[xp.namespacePrefix] :\n                                    undefined;\n                                // console.log(\"+++ \" + xp.namespaceUri);\n                            }\n                        });\n                    }\n                }\n            });\n        }\n        // if (def.properties) {\n        //     def.properties.forEach((propDef) => {\n        //         console.log(propDef.xpathSelectorParsed);\n        //     });\n        // }\n    };\n}\n"]}