{"version":3,"file":"BufferUtils.js","sourceRoot":"","sources":["../../../../../src/_utils/stream/BufferUtils.ts"],"names":[],"mappings":";;;AAAA,2EAA0E;AAG1E,wBAA+B,MAAc;IAEzC,MAAM,CAAC,IAAI,2CAAoB,CAAC,MAAM,CAAC,CAAC;AA+D5C,CAAC;AAjED,wCAiEC;AAED,wCAAqD,UAAiC;;;YAElF,WAAO,IAAI,OAAO,CAAS,UAAC,OAAO,EAAE,MAAM;oBAEvC,IAAM,OAAO,GAAa,EAAE,CAAC;oBAE7B,UAAU,CAAC,EAAE,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;oBAE/B,UAAU,CAAC,EAAE,CAAC,UAAU,EAAE;wBACtB,IAAI,KAAa,CAAC;wBAClB,GAAG,CAAC;4BACA,KAAK,GAAG,UAAU,CAAC,IAAI,EAAY,CAAC;4BACpC,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;gCACR,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;4BACxB,CAAC;wBACL,CAAC,QACM,KAAK,EAAE;oBAClB,CAAC,CAAC,CAAC;oBAEH,UAAU,CAAC,EAAE,CAAC,KAAK,EAAE;wBACjB,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC;oBACpC,CAAC,CAAC,CAAC;gBACP,CAAC,CAAC,EAAC;;;CACN;AAvBD,wEAuBC;AAED,+BAA4C,UAAiC;;;YAEzE,WAAO,IAAI,OAAO,CAAS,UAAC,OAAO,EAAE,MAAM;oBAEvC,IAAM,OAAO,GAAa,EAAE,CAAC;oBAE7B,UAAU,CAAC,EAAE,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;oBAE/B,UAAU,CAAC,EAAE,CAAC,MAAM,EAAE,UAAC,IAAY;wBAC/B,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;oBACvB,CAAC,CAAC,CAAC;oBAEH,UAAU,CAAC,EAAE,CAAC,KAAK,EAAE;wBACjB,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC;oBACpC,CAAC,CAAC,CAAC;gBACP,CAAC,CAAC,EAAC;;;CACN;AAhBD,sDAgBC","sourcesContent":["import { BufferReadableStream } from \"@utils/stream/BufferReadableStream\";\n// import { PassThrough } from \"stream\";\n\nexport function bufferToStream(buffer: Buffer): NodeJS.ReadableStream {\n\n    return new BufferReadableStream(buffer);\n\n    // const stream = new PassThrough();\n\n    // setTimeout(() => {\n\n    //     // stream.write(buffer);\n    //     // stream.end();\n\n    //     // const maxBuffLength = 2048; // 2kB\n    //     let maxBuffLength = 100 * 1024; // 100kB\n\n    //     let buff = buffer;\n    //     let remaining = buff.length;\n    //     let done = 0;\n\n    //     console.log(\"bufferToStream()  BEFORE: \" + remaining);\n\n    //     while (remaining > 0) {\n\n    //         if (done > 0) {\n    //             buff = buffer.slice(done);\n    //             // remaining === buff.length\n    //         }\n\n    //         if (buff.length > maxBuffLength) {\n    //             buff = buff.slice(0, maxBuffLength);\n    //         }\n\n    //         const res = stream.write(buff);\n    //         if (!res) {\n    //             console.log(\"bufferToStream()  highWaterMark\");\n\n    //             // Buffer highWaterMark CHECK\n    //             if ((stream as any)._writableState) {\n    //                 const internalStreamWriteBuffer = (stream as any)._writableState.getBuffer();\n    //                 if (internalStreamWriteBuffer) {\n    //                     console.log(\"bufferToStream() _writableState.getBuffer().length: \"\n    // + internalStreamWriteBuffer.length);\n    //                 }\n    //             }\n\n    //             // Buffer highWaterMark CHECK\n    //             if ((stream as any)._readableState) {\n    //                 const internalStreamReadBuffer = (stream as any)._readableState.buffer;\n    //                 if (internalStreamReadBuffer) {\n    //                     console.log(\"bufferToStream() _readableState.buffer.length: \"\n    // + internalStreamReadBuffer.length);\n    //                 }\n    //             }\n\n    //         }\n\n    //         done += buff.length;\n    //         remaining -= buff.length;\n    //     }\n\n    //     console.log(\"bufferToStream()  AFTER: \" + done);\n\n    //     stream.end();\n    // }, 20);\n\n    // return stream;\n}\n\nexport async function streamToBufferPromise_READABLE(readStream: NodeJS.ReadableStream): Promise<Buffer> {\n\n    return new Promise<Buffer>((resolve, reject) => {\n\n        const buffers: Buffer[] = [];\n\n        readStream.on(\"error\", reject);\n\n        readStream.on(\"readable\", () => {\n            let chunk: Buffer;\n            do {\n                chunk = readStream.read() as Buffer;\n                if (chunk) {\n                    buffers.push(chunk);\n                }\n            }\n            while (chunk);\n        });\n\n        readStream.on(\"end\", () => {\n            resolve(Buffer.concat(buffers));\n        });\n    });\n}\n\nexport async function streamToBufferPromise(readStream: NodeJS.ReadableStream): Promise<Buffer> {\n\n    return new Promise<Buffer>((resolve, reject) => {\n\n        const buffers: Buffer[] = [];\n\n        readStream.on(\"error\", reject);\n\n        readStream.on(\"data\", (data: Buffer) => {\n            buffers.push(data);\n        });\n\n        readStream.on(\"end\", () => {\n            resolve(Buffer.concat(buffers));\n        });\n    });\n}\n"]}