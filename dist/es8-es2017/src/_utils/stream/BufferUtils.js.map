{"version":3,"file":"BufferUtils.js","sourceRoot":"","sources":["../../../../../src/_utils/stream/BufferUtils.ts"],"names":[],"mappings":";;AAAA,6EAA0E;AAG1E,wBAA+B,MAAc;IAEzC,MAAM,CAAC,IAAI,2CAAoB,CAAC,MAAM,CAAC,CAAC;AA+D5C,CAAC;AAjED,wCAiEC;AAEM,KAAK,yCAAyC,UAAiC;IAElF,MAAM,CAAC,IAAI,OAAO,CAAS,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;QAE3C,MAAM,OAAO,GAAa,EAAE,CAAC;QAE7B,UAAU,CAAC,EAAE,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;QAE/B,UAAU,CAAC,EAAE,CAAC,UAAU,EAAE,GAAG,EAAE;YAC3B,IAAI,KAAa,CAAC;YAClB,GAAG,CAAC;gBACA,KAAK,GAAG,UAAU,CAAC,IAAI,EAAY,CAAC;gBACpC,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;oBACR,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBACxB,CAAC;YACL,CAAC,QACM,KAAK,EAAE;QAClB,CAAC,CAAC,CAAC;QAEH,UAAU,CAAC,EAAE,CAAC,KAAK,EAAE,GAAG,EAAE;YACtB,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC;QACpC,CAAC,CAAC,CAAC;IACP,CAAC,CAAC,CAAC;AACP,CAAC;AAvBD,wEAuBC;AAEM,KAAK,gCAAgC,UAAiC;IAEzE,MAAM,CAAC,IAAI,OAAO,CAAS,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;QAE3C,MAAM,OAAO,GAAa,EAAE,CAAC;QAE7B,UAAU,CAAC,EAAE,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;QAE/B,UAAU,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,IAAY,EAAE,EAAE;YACnC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACvB,CAAC,CAAC,CAAC;QAEH,UAAU,CAAC,EAAE,CAAC,KAAK,EAAE,GAAG,EAAE;YACtB,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC;QACpC,CAAC,CAAC,CAAC;IACP,CAAC,CAAC,CAAC;AACP,CAAC;AAhBD,sDAgBC","sourcesContent":["import { BufferReadableStream } from \"@utils/stream/BufferReadableStream\";\n// import { PassThrough } from \"stream\";\n\nexport function bufferToStream(buffer: Buffer): NodeJS.ReadableStream {\n\n    return new BufferReadableStream(buffer);\n\n    // const stream = new PassThrough();\n\n    // setTimeout(() => {\n\n    //     // stream.write(buffer);\n    //     // stream.end();\n\n    //     // const maxBuffLength = 2048; // 2kB\n    //     let maxBuffLength = 100 * 1024; // 100kB\n\n    //     let buff = buffer;\n    //     let remaining = buff.length;\n    //     let done = 0;\n\n    //     console.log(\"bufferToStream()  BEFORE: \" + remaining);\n\n    //     while (remaining > 0) {\n\n    //         if (done > 0) {\n    //             buff = buffer.slice(done);\n    //             // remaining === buff.length\n    //         }\n\n    //         if (buff.length > maxBuffLength) {\n    //             buff = buff.slice(0, maxBuffLength);\n    //         }\n\n    //         const res = stream.write(buff);\n    //         if (!res) {\n    //             console.log(\"bufferToStream()  highWaterMark\");\n\n    //             // Buffer highWaterMark CHECK\n    //             if ((stream as any)._writableState) {\n    //                 const internalStreamWriteBuffer = (stream as any)._writableState.getBuffer();\n    //                 if (internalStreamWriteBuffer) {\n    //                     console.log(\"bufferToStream() _writableState.getBuffer().length: \"\n    // + internalStreamWriteBuffer.length);\n    //                 }\n    //             }\n\n    //             // Buffer highWaterMark CHECK\n    //             if ((stream as any)._readableState) {\n    //                 const internalStreamReadBuffer = (stream as any)._readableState.buffer;\n    //                 if (internalStreamReadBuffer) {\n    //                     console.log(\"bufferToStream() _readableState.buffer.length: \"\n    // + internalStreamReadBuffer.length);\n    //                 }\n    //             }\n\n    //         }\n\n    //         done += buff.length;\n    //         remaining -= buff.length;\n    //     }\n\n    //     console.log(\"bufferToStream()  AFTER: \" + done);\n\n    //     stream.end();\n    // }, 20);\n\n    // return stream;\n}\n\nexport async function streamToBufferPromise_READABLE(readStream: NodeJS.ReadableStream): Promise<Buffer> {\n\n    return new Promise<Buffer>((resolve, reject) => {\n\n        const buffers: Buffer[] = [];\n\n        readStream.on(\"error\", reject);\n\n        readStream.on(\"readable\", () => {\n            let chunk: Buffer;\n            do {\n                chunk = readStream.read() as Buffer;\n                if (chunk) {\n                    buffers.push(chunk);\n                }\n            }\n            while (chunk);\n        });\n\n        readStream.on(\"end\", () => {\n            resolve(Buffer.concat(buffers));\n        });\n    });\n}\n\nexport async function streamToBufferPromise(readStream: NodeJS.ReadableStream): Promise<Buffer> {\n\n    return new Promise<Buffer>((resolve, reject) => {\n\n        const buffers: Buffer[] = [];\n\n        readStream.on(\"error\", reject);\n\n        readStream.on(\"data\", (data: Buffer) => {\n            buffers.push(data);\n        });\n\n        readStream.on(\"end\", () => {\n            resolve(Buffer.concat(buffers));\n        });\n    });\n}\n"]}